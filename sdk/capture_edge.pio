/**
 * Copyright (c) 2022, Daniel Gorbea
 * All rights reserved.
 *
 * This source code is licensed under the MIT-style license found in the
 * LICENSE file in the root directory of this source tree. 
 */

.define PUBLIC PIN_COUNT 2   // use 1 to 32
.define PUBLIC IRQ_NUM 2     // use 0 to 3

.program capture_edge
.define ZERO_COUNT 32-PIN_COUNT
intr:
    mov osr isr        // bk counter
    mov isr ~isr
    push noblock       // send counter
    mov isr x
    push noblock       // send pins
    mov isr y
    push noblock       // send prev
    mov y osr          // restore counter
    mov osr x          // pins to prev
    irq IRQ_NUM        // capture irq
    jmp y-- decr       // adjust counter
decr:
    jmp y-- loop       // adjust counter
.wrap_target
loop:
    in pins PIN_COUNT  // read pins
    in null ZERO_COUNT // fill with zeros
    mov x isr          // pins to x
    mov isr y          // bk counter
    mov y osr          // prev to y
    jmp x!=y intr      // capture irq
    mov y isr          // restore counter
    mov osr x          // prev to osr
    jmp y-- loop       // counter decrement every 9 cycles
public start:
    mov y ~null        // init counter
.wrap

% c-sdk {

#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/irq.h"

#define COUNTER_CYCLES 9

typedef enum edge_type_t
{
    EDGE_NONE,
    EDGE_FALL,
    EDGE_RISE
} edge_type_t;

typedef void (*capture_handler_p_t)(uint counter, edge_type_t edge);

static uint sm_capture_edge;
static PIO pio_capture_edge;
static void (*capture_handler_p[PIN_COUNT])(uint counter, edge_type_t edge) = {NULL};

static inline uint capture_edge_init(PIO pio, uint pin_base, float clk_div, uint irq);
static inline void capture_edge_set_irq(uint pin, capture_handler_p_t handler);
static inline void capture_edge_irq();
static inline edge_type_t get_captured_edge(uint pin, uint pins, uint prev);
static inline uint bit_value(uint pos);

static inline uint capture_edge_init(PIO pio, uint pin_base, float clk_div, uint irq)
{
    pio_capture_edge = pio;
    sm_capture_edge = pio_claim_unused_sm(pio, true);
    uint offset = pio_add_program(pio, &capture_edge_program);
    pio_sm_set_consecutive_pindirs(pio, sm_capture_edge, pin_base, PIN_COUNT, false);
    pio_sm_config c = capture_edge_program_get_default_config(offset);
    sm_config_set_clkdiv(&c, clk_div);
    sm_config_set_in_pins(&c, pin_base);
    if (irq == PIO0_IRQ_0 || irq == PIO1_IRQ_0)
        pio_set_irq0_source_enabled(pio, (enum pio_interrupt_source)(pis_interrupt0 + IRQ_NUM), true);
    else
        pio_set_irq1_source_enabled(pio, (enum pio_interrupt_source)(pis_interrupt0 + IRQ_NUM), true);
    pio_interrupt_clear(pio, IRQ_NUM);
    pio_sm_init(pio, sm_capture_edge, offset + capture_edge_offset_start, &c);
    pio_sm_set_enabled(pio, sm_capture_edge, true);
    irq_set_exclusive_handler(irq, capture_edge_irq);
    irq_set_enabled(irq, true);

    return sm_capture_edge;
}

static inline void capture_edge_irq()
{
    static uint counter_prev = 0;
    if (pio_sm_is_rx_fifo_full(pio_capture_edge, sm_capture_edge))
    {
        pio_sm_clear_fifos(pio_capture_edge, sm_capture_edge);
        return;
    }
    uint counter = pio_sm_get_blocking(pio_capture_edge, sm_capture_edge);
    uint pins = pio_sm_get_blocking(pio_capture_edge, sm_capture_edge);
    uint prev = pio_sm_get_blocking(pio_capture_edge, sm_capture_edge);

    for (uint pin = 0; pin < PIN_COUNT; pin++)
    {
        edge_type_t edge = get_captured_edge(pin, pins, prev);
        if (edge && *capture_handler_p[pin])
        {
            capture_handler_p[pin](counter, edge);
        }
    }

    pio_interrupt_clear(pio_capture_edge, IRQ_NUM);
}

static inline edge_type_t get_captured_edge(uint pin, uint pins, uint prev)
{
    if ((bit_value(pin) & pins) ^ (bit_value(pin) & prev) && (bit_value(pin) & pins))
        return EDGE_RISE;
    if ((bit_value(pin) & pins) ^ (bit_value(pin) & prev) && !(bit_value(pin) & pins))
        return EDGE_FALL;
    return EDGE_NONE;
}

static inline void capture_edge_set_irq(uint pin, capture_handler_p_t handler)
{
    if (pin < PIN_COUNT)
    {
        capture_handler_p[pin] = handler;
    }
}

static inline uint bit_value(uint pos)
{
    return 1 << pos;
}

%}